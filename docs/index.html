<!DOCTYPE html>
<html class="theme-pong">
<head>
    <title>Rainbow V Manager</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="#key-features">Key Features</a></li>
                <li><a href="#quick-links">Quick Links</a></li>
		<li><a href="https://github.com/aginies/vmanager" target="_blank">Source code</a></li>
                <li><a href="#license">License</a></li>
                <li><a href="media.html">Media</a></li>
            </ul>
        </nav>
    </header>
    
    <div class="content">
        <h1>Rainbow V Manager</h1>
	<p>A Textual-based TUI (Terminal User Interface) application for managing QEMU/KVM virtual machines using the libvirt python API.</p><p>Author: aginies@suse.com</p>
        
        <h2 id="key-features">Key Features</h2>

        <h3>Overall Architecture &amp; UX</h3>
        <ul class="feature-list">
            <li><strong>Zero X11 Dependency</strong>: Full control via terminal, eliminating the need for graphical environments.</li>
            <li><strong>Multi-Server Transhypervisor View</strong>: Visualize and manage VMs across multiple hypervisors from a unified interface.</li>
            <li><strong>Low-Bandwidth Remote Operations</strong>: Efficient remote administration ideal for cloud and edge environments.</li>
            <li><strong>Color-Coded Status &amp; Server Identification</strong>: Use intuitive color schemes to indicate VM status and server origins for quick identification.</li>
        </ul>

        <h3>Server &amp; Host Management</h3>
        <ul class="feature-list">
            <li><strong>Host Resource Management</strong>: Manage not just VMs, but also the underlying server resources like Storage Pools and Virtual Networks.</li>
            <li><strong>Embedded Virsh Shell</strong>: Instantly access a `virsh` shell for any managed server directly within the application for advanced commands.</li>
            <li><strong>Websockify SSH &amp; noVNC Integration</strong>: Enable secure SSH and noVNC remote viewing for headless server environments.</li>
            <li><strong>Move Storage Volume</strong>: Move storage volumes between different pools, updating VM guest config if needed.</li>
        </ul>

        <h3>Virtual Machine Management</h3>
        <ul class="feature-list">
            <li><strong>Scalable VM Management</strong>: Manage hundreds of VMs across multiple libvirt servers with a single, consistent interface.</li>
            <li><strong>Live Performance Monitoring</strong>: View real-time CPU and memory usage with sparkline graphs on each VM card.</li>
            <li><strong>In-Depth Hardware Configuration</strong>: Control virtually all aspects of a VM's hardware, from CPU and memory to UEFI, Secure Boot, TPM, and boot order.</li>
            <li><strong>Full Snapshot Management</strong>: Easily create, delete, and revert to VM snapshots through the interface.</li>
            <li><strong>Advanced VM Resource Control</strong>: Disable disks, switch machine types, etc..</li>
            <li><strong>VM Migration</strong>: Migrate VMs offline and live between servers, with pre-checks on server and VM guest config.</li>
            <li><strong>Clone VM Capabilities</strong>: Clone VMs with advanced options, including specifying a custom suffix, cloning multiple instances at once, and automatic creation of storage for the new clones.</li>
            <li><strong>Bulk Command Execution</strong>: Execute commands across multiple selected VMs simultaneously for streamlined management.</li>
            <li><strong>Spice to VNC Transition</strong>: Automatically replace Spice graphics with VNC for simplified remote access and reduced resource usage.</li>
        </ul>

        <h3 id="cli-features">Command-Line Interface (vmanager_cmd.py)</h3>
        <ul class="feature-list">
            <li><strong>Multi-server Management</strong>: Connect to and manage multiple <code>libvirt</code> servers simultaneously from a single shell.</li>
            <li><strong>Bulk VM Operations</strong>: Execute commands like <code>start</code>, <code>stop</code>, and <code>status</code> on multiple VMs across different servers at once.</li>
            <li><strong>Advanced VM Selection</strong>: Select VMs for operations using direct names or regular expression patterns.</li>
            <li><strong>Storage Management</strong>: List storage pools and unused volumes across all connected servers.</li>
            <li><strong>Tab Autocompletion</strong>: Context-aware autocompletion for server names, VM names, and storage pools.</li>
        </ul>

	<h2 id="xp-features">Experimental Features</h2>
	<ul class="xp-list">
	    <li><strong>Detect common pool</strong>: Detect common pool between server.</li>
	</ul>
        
        <div class="media-section">
            <img src="https://paste.opensuse.org/pastes/d4f485dd7c3c/raw" alt="Rainbow V Manager Interface Screenshot" title="Rainbow V Manager Interface" width="800">
            <p>Interface showing multi-server VM management with color-coded status indicators</p>
        </div>
        
        <h2 id="quick-links">Quick Links</h2>
        <ul class="feature-list">
            <li><a href="https://github.com/aginies/vmanager/blob/main/README.md">Read the full documentation</a></li>
            <li><a href="https://github.com/aginies/vmanager/blob/main/FEATURES.md">View features list</a></li>
            <li><a href="https://github.com/aginies/vmanager">GitHub Repository</a></li>
        </ul>
        <div class="license-section">
        <h2 id="license">License</h2>
        <p>License: <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GPL3</a></p>
    </div>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const theme = document.documentElement.className;
        const container = document.body;

        // --- Theme-based Animation Controller ---
        if (theme.includes('christmas') || theme.includes('dark')) {
            createSnowflakesAndStars();
        } else if (theme.includes('ufo')) {
            createUFOs();
        } else if (theme.includes('pong')) {
            createPongGame();
        }

        // --- Animation Functions ---

        function createPongGame() {
            const container = document.body;
            let playerPaddle, aiPaddle, ball;
            let ballState = { x: 0, y: 0, dx: 8, dy: 5 };

            function init() {
                // Create elements
                playerPaddle = document.createElement('div');
                playerPaddle.classList.add('paddle');
                playerPaddle.style.left = '20px';

                aiPaddle = document.createElement('div');
                aiPaddle.classList.add('paddle');
                aiPaddle.style.right = '20px';

                ball = document.createElement('div');
                ball.classList.add('ball');
                
                container.append(playerPaddle, aiPaddle, ball);

                // Event Listeners
                document.addEventListener('mousemove', movePlayerPaddle);
                
                resetBall();
                requestAnimationFrame(updateGame);
            }

            function movePlayerPaddle(e) {
                const paddleHeight = playerPaddle.offsetHeight;
                let newY = e.clientY - paddleHeight / 2;
                if (newY < 0) newY = 0;
                if (newY > window.innerHeight - paddleHeight) newY = window.innerHeight - paddleHeight;
                playerPaddle.style.top = `${newY}px`;
            }

            function resetBall() {
                ballState.x = window.innerWidth / 2;
                ballState.y = window.innerHeight / 2;
                // Set initial horizontal speed and random direction
                ballState.dx = (Math.random() > 0.5 ? 1 : -1) * 6; // Initial speed 6, random direction
                ballState.dy = (Math.random() - 0.5) * 5;
            }

            function updateGame() {
                // Move ball
                ballState.x += ballState.dx;
                ballState.y += ballState.dy;

                ball.style.left = `${ballState.x}px`;
                ball.style.top = `${ballState.y}px`;

                // Ball collision: Top/Bottom walls
                if (ballState.y <= 0 || ballState.y >= window.innerHeight - ball.offsetHeight) {
                    ballState.dy *= -1;
                }

                // Ball collision: Paddles
                const ballRect = ball.getBoundingClientRect();
                const playerRect = playerPaddle.getBoundingClientRect();
                const aiRect = aiPaddle.getBoundingClientRect();

                if (ballRect.left <= playerRect.right && ballRect.top > playerRect.top && ballRect.bottom < playerRect.bottom) {
                    ballState.dx *= -1.1; // Speed up on hit
                }
                if (ballRect.right >= aiRect.left && ballRect.top > aiRect.top && ballRect.bottom < aiRect.bottom) {
                    ballState.dx *= -1.1; // Speed up on hit
                }

                // Ball collision: Left/Right walls
                if (ballState.x <= 0 || ballState.x >= window.innerWidth) {
                    resetBall();
                }

                // AI Paddle Movement
                const aiCenter = aiPaddle.offsetTop + aiPaddle.offsetHeight / 2;
                const ballCenter = ballState.y + ball.offsetHeight / 2;
                const speed = 4; // AI speed
                if (aiCenter < ballCenter - 10) {
                    aiPaddle.style.top = `${aiPaddle.offsetTop + speed}px`;
                } else if (aiCenter > ballCenter + 10) {
                    aiPaddle.style.top = `${aiPaddle.offsetTop - speed}px`;
                }

                requestAnimationFrame(updateGame);
            }
            
            init();
        }
        
        function createMatrixRain() {
            const container = document.body;
            const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789„Ç¢„Ç°„Ç´„Çµ„Çø„Éä„Éè„Éû„É§„É£„É©„ÉØ„Ç¨„Ç∂„ÉÄ„Éê„Éë„Ç§„Ç£„Ç≠„Ç∑„ÉÅ„Éã„Éí„Éü„É™„É∞„ÇÆ„Ç∏„ÉÇ„Éì„Éî„Ç¶„Ç•„ÇØ„Çπ„ÉÑ„Éå„Éï„É†„É¶„É•„É´„Ç∞„Ç∫„Éñ„ÉÖ„Éó„Ç®„Çß„Ç±„Çª„ÉÜ„Éç„Éò„É°„É¨„É±„Ç≤„Çº„Éá„Éô„Éö„Ç™„Ç©„Ç≥„ÇΩ„Éà„Éé„Éõ„É¢„É®„Éß„É≠„É≤„Ç¥„Çæ„Éâ„Éú„Éù„É¥„ÉÉ„É≥';
            const streamSpacing = 10; // Increased density by reducing spacing

            // Define content area boundaries
            const mainContentWidth = 800;
            const contentLeftEdge = (window.innerWidth - mainContentWidth) / 2;
            const contentRightEdge = contentLeftEdge + mainContentWidth;

            for (let i = 0; i * streamSpacing < window.innerWidth; i++) {
                const x = i * streamSpacing;

                // Skip the central content area
                if (x > contentLeftEdge && x < contentRightEdge) {
                    continue;
                }

                const stream = document.createElement('div');
                stream.classList.add('matrix-stream');
                
                let streamContent = '';
                const streamLength = Math.floor(Math.random() * 30) + 25; // Increased length: 25 to 55 chars long
                for(let j = 0; j < streamLength; j++) {
                    streamContent += chars[Math.floor(Math.random() * chars.length)];
                }
                
                const firstChar = streamContent.charAt(0);
                const restChars = streamContent.substring(1);
                stream.innerHTML = `<span class="matrix-leader">${firstChar}</span>${restChars}`;

                stream.style.left = `${x}px`;
                stream.style.top = '-550px';
                stream.style.animationDuration = `${Math.random() * 8 + 8}s`; // Slower speed: 8-16 seconds
                stream.style.animationDelay = `${Math.random() * 15}s`;
                
                container.appendChild(stream);
            }
        }
        
        function createSnowflakesAndStars() {
            const starCount = 100;
            const snowflakeCount = 40;

            // Create stars
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.classList.add('star');
                star.style.top = `${Math.random() * 100}%`;
                star.style.left = `${Math.random() * 100}%`;
                star.style.animationDelay = `${Math.random() * 3}s`;
                star.style.animationDuration = `${Math.random() * 2 + 1.5}s`;
                container.appendChild(star);
            }

            // Create snowflakes
            const snowflakeContent = ['‚ùÑÔ∏è', '‚ùÖ', '‚ùÜ'];
            for (let i = 0; i < snowflakeCount; i++) {
                const snowflake = document.createElement('div');
                snowflake.classList.add('snowflake');
                snowflake.textContent = snowflakeContent[Math.floor(Math.random() * snowflakeContent.length)];
                snowflake.style.left = `${Math.random() * 100}vw`;
                snowflake.style.animationDuration = `${Math.random() * 8 + 7}s`;
                snowflake.style.animationDelay = `${Math.random() * 10}s`;
                snowflake.style.fontSize = `${Math.random() * 15 + 10}px`;
                snowflake.style.opacity = Math.random() * 0.7 + 0.3;
                container.appendChild(snowflake);
            }
        }

        function createUFOs() {
            const ufoTypes = ['üõ∏', 'üöÄ', 'üõ∞Ô∏è', 'ship'];
            
            setInterval(() => {
                const ufoType = ufoTypes[Math.floor(Math.random() * ufoTypes.length)];

                const ufo = document.createElement('div');
                ufo.classList.add('ufo');

                const visualContainer = document.createElement('div');
                
                if (ufoType === 'ship') {
                    visualContainer.classList.add('ufo-ship');
                } else {
                    visualContainer.classList.add('ufo-emoji');
                    visualContainer.textContent = ufoType;
                }
                ufo.appendChild(visualContainer);

                // Randomize vertical position, speed, and size
                const startY = Math.random() * window.innerHeight * 0.8;
                const duration = Math.random() * 8 + 8; // 8 to 16 seconds
                const scale = Math.random() * 0.5 + 0.6; // 0.6x to 1.1x size

                ufo.style.top = `${startY}px`;
                ufo.style.animationDuration = `${duration}s`;
                ufo.style.transform = `scale(${scale})`;

                container.appendChild(ufo);

                setTimeout(() => {
                    ufo.remove();
                }, duration * 1000);

            }, 1500); // New UFO every 1.5 seconds
        }
    });
    </script>
</body>
</html>
